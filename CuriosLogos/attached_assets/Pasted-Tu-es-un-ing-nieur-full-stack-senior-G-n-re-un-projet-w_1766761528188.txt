Tu es un ingénieur full-stack senior. Génère un projet web complet (repo prêt à lancer) pour un MVP “agrégateur de sujets” (France, presse écrite généraliste).

OBJECTIF PRODUIT
- On agrège des articles (titres + URL + date + média + extrait court si dispo via RSS) depuis 11 médias:
  Le Monde, Le Figaro, Libération, Les Echos, L’Opinion, La Croix, Le Parisien, Agefi, Mediapart, La Tribune, L’Humanité.
- Le produit affiche des pages “Sujet”. Une page = un sujet éditorial (créé via un back-office simple).
- Chaque page Sujet contient :
  1) Une synthèse pragmatique et froide (champ texte, éditable)
  2) Un graphique scatter 2D (axes politiques non définis; on stocke juste x,y par média) et on place uniquement les médias qui ont au moins un article dans ce sujet
  3) La liste des articles liés au sujet: Titre de l’article + nom du média dessous + date + lien externe
  4) Une micro-analyse (1-3 phrases) de différence de traitement selon le spectre (champ texte, éditable)

CONTRAINTES IMPORTANTES
- “Link-first”: ne pas scraper le full-text des articles. On se limite aux métadonnées RSS/Atom (title, link, pubDate, description si fournie).
- Déduplication: pas de doublons d’URL en base. Conserver un hash de l’URL canonique.
- Un MVP doit être simple, stable, et facile à faire évoluer.

STACK TECHNIQUE (à imposer)
- Backend: Node.js + TypeScript + NestJS (ou Fastify si tu préfères, mais REST simple)
- DB: PostgreSQL + Prisma ORM
- Frontend: Next.js (App Router) + TypeScript
- UI: Tailwind CSS (simple, propre)
- Chart: Recharts (scatter plot)
- Auth: pour MVP, un “admin mode” par mot de passe dans .env (pas de gestion users complète)
- Ingestion: un script Node (TypeScript) lancé manuellement + planifiable (cron) qui lit des RSS et remplit la DB

LIVRABLE ATTENDU (repo)
- Un monorepo (pnpm ou npm workspaces) avec:
  /apps/api   (NestJS)
  /apps/web   (Next.js)
  /packages/db (Prisma schema + migrations)
  /scripts/ingest (script RSS)
- Un README clair avec:
  - prérequis
  - configuration .env
  - commandes pour lancer DB (docker-compose), migrer, lancer api/web, lancer ingestion
- docker-compose.yml pour PostgreSQL
- Seeds: création des 11 médias avec (name, slug, x, y) valeurs par défaut

MODELE DE DONNEES (Prisma)
- Media:
  id (uuid)
  name (string)
  slug (unique)
  axisX (float) default 0
  axisY (float) default 0
  createdAt, updatedAt
- Article:
  id (uuid)
  mediaId (fk)
  url (unique)
  urlHash (unique)
  title (string)
  excerpt (string nullable)
  publishedAt (datetime)
  createdAt
  index(mediaId, publishedAt)
- Topic (Sujet):
  id (uuid)
  slug (unique)
  title (string)
  summary (text)  // synthèse froide
  angleNote (text) // micro-analyse
  startAt (datetime nullable)
  endAt (datetime nullable)
  createdAt, updatedAt
- TopicArticle (join):
  topicId
  articleId
  unique(topicId, articleId)

API REST (NestJS)
- Public:
  GET /topics                 -> liste paginée (title, slug, dates, nbArticles)
  GET /topics/:slug           -> détail sujet + articles + médias inclus + coords (x,y)
  GET /media                  -> liste des médias (name, slug, x,y)
- Admin (protégé par header "x-admin-token" == ADMIN_TOKEN):
  POST /topics                -> create (title, slug?, dates?)
  PATCH /topics/:id           -> update summary/angleNote/title/dates
  DELETE /topics/:id
  POST /topics/:id/articles   -> associer un article existant à un sujet (articleId)
  DELETE /topics/:id/articles/:articleId -> retirer
  PATCH /media/:id            -> modifier axisX/axisY (pour le scatter)
  GET /admin/articles         -> recherche articles (query, media, date range) pour aider à associer à un sujet

FRONT WEB (Next.js)
- Pages:
  / (home): liste des sujets (cards)
  /topics/[slug]: page Sujet
  /media: page listant les médias et leurs coords
  /admin: page admin (form simple) protégée par saisie du token (stocké en localStorage)
  /admin/topics/[id]: éditeur de sujet:
      - champs: title, summary, angleNote, dates
      - panneau recherche d’articles (appel /admin/articles) + bouton “Ajouter au sujet”
- Composants:
  - TopicHeader
  - TopicScatterPlot (Recharts ScatterChart)
  - ArticleList (cards)
  - AdminGuard (gère token)
  - MediaLegend (liste des médias présents dans le sujet)

SCATTER PLOT (détails)
- Chaque média = un point (x=axisX, y=axisY).
- On n’affiche que les médias ayant au moins un article sur ce topic.
- Tooltip au hover: nom du média + nombre d’articles sur ce topic.

INGESTION RSS (script)
- Fichier de config: sources.ts contenant un tableau de { mediaSlug, feedUrl }
- Le script:
  - fetch feed XML
  - parse items
  - map vers Article (url, title, excerpt, publishedAt)
  - normalise URL (trim, enlever trackers si simple)
  - calcule urlHash (sha256)
  - upsert par urlHash (ou url unique)
  - ignore si publishedAt manquant: mettre Date.now mais logguer un warning
- Logging clair + compteur (nouveaux / ignorés / erreurs)

CONFIG ENV (.env.example)
- DATABASE_URL
- ADMIN_TOKEN
- API_PORT
- WEB_BASE_URL
- (optionnel) CORS_ORIGINS

QUALITE / DX
- TypeScript strict
- Validation DTO (class-validator ou zod)
- Gestion erreurs API propre
- Pagination basique
- Tests: facultatif MVP mais structure prête
- Lint/format (eslint + prettier)

IMPORTANT
- N’invente pas des feeds si tu ne les connais pas. Mets des placeholders de feedUrl “TODO” dans sources.ts, mais structure le code pour que ce soit trivial à remplir.
- Fournis un design UI propre et minimal.

GENERE LE CODE COMPLET
- Donne l’arborescence du repo et le contenu des fichiers essentiels.
- Assure-toi que “docker-compose up -d”, “prisma migrate”, “npm run dev” marchent.
- Inclure des scripts package.json:
  - dev (lance web + api)
  - db:up, db:down
  - prisma:migrate, prisma:seed
  - ingest (lance le script ingestion)
